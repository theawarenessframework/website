#!/usr/bin/env python3
"""
omp_bifurcation.py

Reproducible bifurcation / parameter-sweep script for the OMP (Observer-Memory-Pattern)
continuous ODE toy model used in the manuscript appendix.

Features:
- Implements the same ODE core as the paper.
- Performs parameter sweeps over `alpha_gain` (user-configurable grid).
- Trims a transient (absolute time) and computes oscillation amplitudes (max-min)
  for O, M, P after transient.
- Attempts to find a nearby fixed point and compute Jacobian eigenvalues.
- Saves CSV results and publication-ready figures (PNG/SVG) to an output folder.
- Provides a fine local sweep mode to refine the threshold region.

Reproducibility notes:
- Deterministic ODE integration (no stochastic terms) — results should be identical
  across machines with the same library versions.
- For publication, include Python + package versions (see --save-env).

Usage examples:
    python omp_bifurcation.py --gain-min 0.5 --gain-max 6.0 --gain-steps 23 --outdir results
    python omp_bifurcation.py --local-refine 1.8 2.4 0.02 --outdir results/refined

Requirements:
- Python 3.8+
- numpy, scipy, matplotlib, pandas

Author: Generated by ChatGPT for reproducible research (adjust as needed)
"""

import os
import argparse
import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import fsolve
from numpy.linalg import eigvals
from scipy.signal import find_peaks
import pandas as pd
import json
import sys

# ----------------------------
# Model definition
# ----------------------------

def omp_ode_system(t, y, pars):
    """Right-hand side of the OMP ODE system.

    Parameters
    ----------
    t : float
        Time (unused explicitly: autonomous system)
    y : array_like, shape (3,)
        State vector [O, M, P]
    pars : sequence
        Parameters [alpha_O, alpha_M, alpha_P, mu_M, mu_P, alpha_gain]
    """
    O, M, P = y
    alpha_O, alpha_M, alpha_P, mu_M, mu_P, alpha_gain = pars

    def sigmoid(x):
        # Numerically stable sigmoid
        return 1.0 / (1.0 + np.exp(-x))

    I_O = 0.6 * O + alpha_gain * np.tanh(M - P)
    dOdt = alpha_O * (sigmoid(I_O) - O)
    dMdt = alpha_M * (0.1 * O - mu_M * M)
    dPdt = alpha_P * (0.1 * M - mu_P * P)
    return [dOdt, dMdt, dPdt]


def jacobian_fd(fun, y0, pars, eps=1e-8):
    """Finite-difference Jacobian approximation (columns are partials wrt variables).
    Returns J where J[i,j] = d f_i / d y_j.
    """
    y0 = np.asarray(y0, dtype=float)
    n = y0.size
    J = np.zeros((n,n), dtype=float)
    f0 = np.asarray(fun(0.0, y0, pars))
    for j in range(n):
        yp = y0.copy()
        yp[j] += eps
        fp = np.asarray(fun(0.0, yp, pars))
        J[:, j] = (fp - f0) / eps
    return J


# ----------------------------
# Utilities
# ----------------------------

def estimate_period_from_signal(signal, t, prominence=1e-4):
    """Estimate mean period using peak detection; returns (period, npeaks) or (None,0)."""
    peaks, props = find_peaks(signal, prominence=prominence)
    if peaks.size > 1:
        periods = np.diff(t[peaks])
        return float(np.mean(periods)), int(peaks.size)
    # fallback: try smaller prominence
    peaks2, _ = find_peaks(signal, prominence=prominence*0.1)
    if peaks2.size > 1:
        return float(np.mean(np.diff(t[peaks2]))), int(peaks2.size)
    return None, 0


def ensure_dir(d):
    os.makedirs(d, exist_ok=True)
    return os.path.abspath(d)


# ----------------------------
# Main sweep routine
# ----------------------------

def run_sweep(alpha_O=1.0, alpha_M=1.0, alpha_P=1.0, mu_M=0.02, mu_P=0.02,
              gain_min=0.5, gain_max=6.0, gain_steps=23,
              y0=None, TSPAN=(0.0, 1000.0), n_t=5000,
              transient_time=200.0, rtol=1e-8, atol=1e-10,
              outdir='results', name_prefix='omp_sweep'):
    """Run a parameter sweep over alpha_gain and save results + figures.

    Returns
    -------
    df : pandas.DataFrame
        Dataframe with columns: alpha_gain, O_range, M_range, P_range, period_O, npeaks_O, eig_real_parts
    """
    outdir = ensure_dir(outdir)
    t_eval = np.linspace(TSPAN[0], TSPAN[1], n_t)
    gains = np.linspace(gain_min, gain_max, gain_steps)

    if y0 is None:
        y0 = np.array([0.1, 0.3, 0.2])

    rows = []

    for g in gains:
        pars = [alpha_O, alpha_M, alpha_P, mu_M, mu_P, float(g)]
        sol = solve_ivp(omp_ode_system, TSPAN, y0, args=(pars,), t_eval=t_eval,
                        method='RK45', rtol=rtol, atol=atol)
        if not sol.success:
            print(f"Warning: solver failed for gain={g}: {sol.message}")
            rows.append({'alpha_gain': float(g), 'O_range': np.nan, 'M_range': np.nan, 'P_range': np.nan,
                         'period_O': np.nan, 'npeaks_O': 0, 'eigvals_real': None})
            continue

        O, M, P = sol.y
        idx0 = np.searchsorted(sol.t, transient_time, side='left')
        O_s = O[idx0:]; M_s = M[idx0:]; P_s = P[idx0:]; t_s = sol.t[idx0:]

        O_range = float(np.max(O_s) - np.min(O_s))
        M_range = float(np.max(M_s) - np.min(M_s))
        P_range = float(np.max(P_s) - np.min(P_s))

        # period estimate on O
        period_O, npeaks_O = estimate_period_from_signal(O_s, t_s, prominence=max(1e-6, O_range*0.05))

        # try to find nearest fixed point (fsolve) starting from last state
        eigs = None
        try:
            def rootfun(y):
                return omp_ode_system(0.0, y, pars)
            # fsolve may warn when convergence is slow; catch but continue
            y_star = fsolve(rootfun, x0=np.array([O[-1], M[-1], P[-1]]), xtol=1e-12, maxfev=5000)
            J = jacobian_fd(omp_ode_system, y_star, pars, eps=1e-8)
            eigs = eigvals(J)
        except Exception:
            eigs = None

        eigs_real = None
        if eigs is not None:
            eigs_real = [float(np.real(ev)) for ev in eigs]

        rows.append({'alpha_gain': float(g), 'O_range': O_range, 'M_range': M_range, 'P_range': P_range,
                     'period_O': (float(period_O) if period_O is not None else np.nan),
                     'npeaks_O': int(npeaks_O), 'eigvals_real': eigs_real})

    df = pd.DataFrame(rows)
    csv_path = os.path.join(outdir, f"{name_prefix}_results.csv")
    df.to_csv(csv_path, index=False)
    print(f"Saved sweep results to {csv_path}")

    # Plot amplitude vs gain
    fig1, ax1 = plt.subplots(figsize=(8,5))
    ax1.plot(df['alpha_gain'], df['O_range'], label='O_range')
    ax1.plot(df['alpha_gain'], df['M_range'], label='M_range')
    ax1.plot(df['alpha_gain'], df['P_range'], label='P_range')
    ax1.set_xlabel('alpha_gain')
    ax1.set_ylabel('Oscillation range (max-min after transient)')
    ax1.set_title('OMP amplitude vs alpha_gain (post-transient)')
    ax1.legend()
    ax1.grid(True)
    fig1.tight_layout()
    fig1.savefig(os.path.join(outdir, f"{name_prefix}_amplitude_vs_gain.png"), dpi=300)
    fig1.savefig(os.path.join(outdir, f"{name_prefix}_amplitude_vs_gain.svg"))
    plt.close(fig1)

    # pick representative gain (max O_range) for time series and phase portrait
    if np.nanmax(df['O_range'].values) > 0:
        pick_idx = int(np.nanargmax(df['O_range'].values))
    else:
        pick_idx = len(gains)//2
    pick_gain = float(df['alpha_gain'].iloc[pick_idx])
    pars_pick = [alpha_O, alpha_M, alpha_P, mu_M, mu_P, pick_gain]
    sol_pick = solve_ivp(omp_ode_system, TSPAN, y0, args=(pars_pick,), t_eval=t_eval, method='RK45', rtol=rtol, atol=atol)
    O_p, M_p, P_p = sol_pick.y
    idx0 = np.searchsorted(sol_pick.t, transient_time, side='left')
    t_p = sol_pick.t[idx0:]
    O_p_s = O_p[idx0:]; M_p_s = M_p[idx0:]; P_p_s = P_p[idx0:]

    # time series
    fig2, ax2 = plt.subplots(figsize=(10,4))
    ax2.plot(t_p, O_p_s, label='O (Observation)')
    ax2.plot(t_p, M_p_s, label='M (Memory)', linestyle='--')
    ax2.plot(t_p, P_p_s, label='P (Pattern)', linestyle=':')
    ax2.set_xlabel('Time')
    ax2.set_ylabel('Value')
    ax2.set_title(f'Time series after transient (alpha_gain = {pick_gain:.4f})')
    ax2.legend()
    fig2.tight_layout()
    fig2.savefig(os.path.join(outdir, f"{name_prefix}_timeseries_gain_{pick_gain:.4f}.png"), dpi=300)
    fig2.savefig(os.path.join(outdir, f"{name_prefix}_timeseries_gain_{pick_gain:.4f}.svg"))
    plt.close(fig2)

    # phase portrait O vs M
    fig3, ax3 = plt.subplots(figsize=(5,5))
    ax3.plot(O_p_s, M_p_s)
    ax3.set_xlabel('O')
    ax3.set_ylabel('M')
    ax3.set_title(f'Phase portrait (O vs M) after transient (gain={pick_gain:.4f})')
    fig3.tight_layout()
    fig3.savefig(os.path.join(outdir, f"{name_prefix}_phase_OvM_gain_{pick_gain:.4f}.png"), dpi=300)
    fig3.savefig(os.path.join(outdir, f"{name_prefix}_phase_OvM_gain_{pick_gain:.4f}.svg"))
    plt.close(fig3)

    # Save metadata (parameters and versions) — minimal
    meta = {
        'alpha_O': alpha_O, 'alpha_M': alpha_M, 'alpha_P': alpha_P,
        'mu_M': mu_M, 'mu_P': mu_P, 'gain_min': gain_min, 'gain_max': gain_max,
        'gain_steps': gain_steps, 'y0': list(map(float, y0)), 'TSPAN': list(TSPAN),
        'n_t': n_t, 'transient_time': transient_time, 'rtol': rtol, 'atol': atol
    }
    with open(os.path.join(outdir, f"{name_prefix}_meta.json"), 'w') as f:
        json.dump(meta, f, indent=2)

    print(f"Saved figures and meta to {outdir}")
    return df


# ----------------------------
# CLI
# ----------------------------

def parse_args(argv=None):
    ap = argparse.ArgumentParser(description='OMP bifurcation / sweep script (reproducible)')
    ap.add_argument('--gain-min', type=float, default=0.5)
    ap.add_argument('--gain-max', type=float, default=6.0)
    ap.add_argument('--gain-steps', type=int, default=23)
    ap.add_argument('--outdir', type=str, default='results')
    ap.add_argument('--transient', type=float, default=200.0)
    ap.add_argument('--T', type=float, default=1000.0)
    ap.add_argument('--n-t', type=int, default=5000)
    ap.add_argument('--y0', type=float, nargs=3, default=[0.1, 0.3, 0.2])
    ap.add_argument('--save-env', action='store_true', help='save python package versions to env.json')
    ap.add_argument('--local-refine', type=float, nargs=3,
                    metavar=('REF_MIN', 'REF_MAX', 'REF_STEP'),
                    help='optional local refinement grid (overrides gain-min/gain-max/gain-steps)')
    return ap.parse_args(argv)


def save_env(outdir):
    try:
        import pkg_resources
        packages = {pkg.key: pkg.version for pkg in pkg_resources.working_set}
        with open(os.path.join(outdir, 'env_packages.json'), 'w') as f:
            json.dump(packages, f, indent=2)
        print('Saved environment package versions to env_packages.json')
    except Exception as e:
        print('Could not save env packages:', e)


def main(argv=None):
    args = parse_args(argv)
    outdir = args.outdir
    ensure_dir(outdir)

    if args.local_refine is not None:
        ref_min, ref_max, ref_step = args.local_refine
        gains = np.arange(ref_min, ref_max + 1e-12, ref_step)
        gain_min, gain_max, gain_steps = float(ref_min), float(ref_max), int(len(gains))
    else:
        gain_min, gain_max, gain_steps = args.gain_min, args.gain_max, args.gain_steps

    df = run_sweep(alpha_O=1.0, alpha_M=1.0, alpha_P=1.0,
                   mu_M=0.02, mu_P=0.02,
                   gain_min=gain_min, gain_max=gain_max, gain_steps=gain_steps,
                   y0=np.array(args.y0), TSPAN=(0.0, float(args.T)), n_t=int(args.n_t),
                   transient_time=float(args.transient), outdir=outdir,
                   name_prefix='omp_sweep')

    if args.save_env:
        save_env(outdir)

    # Print short summary
    print('\nSweep summary head:')
    print(df.head())
    print(f"Results and figures are in: {os.path.abspath(outdir)}")


if __name__ == '__main__':
    main()
